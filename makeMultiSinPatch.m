function patch = makeMultiSinPatch(sinpat,contrast,ncolors)% sinpat.siz = 100;% sinpat.sup = 20;% sinpat.spFreq = 10;% sinpat.orient = [pi/4 3*pi/4];% sinpat.phase = [0 0];% contrast = [0.5 0.5];% ncolors = 256;xsize = sinpat.siz+2*sinpat.sup;ysize = xsize;thefreq = sinpat.spFreq*xsize/(xsize-2*sinpat.sup);[X,Y] = meshgrid(0:(xsize-1),0:(ysize-1));sd = round(sinpat.sup/6);					%Blur the edges by convolution; sup is blank space that surrounds the patchif sd == 0    sd = 1;endenv = ones(ysize,xsize);					%Result of convolution eventuallyrawr=sqrt((X-xsize/2).^2+(Y-ysize/2).^2);out = find(rawr > (xsize/2-sinpat.sup));env(out) = zeros(size(out)); kern = mkGaussKernel(sinpat.sup,sd);				%Gaussian for convolutionenv = cirConv2(env,kern);env = env./max(max(env));zeromat = env > 0.005;env = env.*zeromat;patch = zeros(size(env));for i = 1:length(sinpat.orient)    val=(cos(thefreq*2*pi/xsize*(X.*cos(sinpat.orient(i))+Y.*sin(sinpat.orient(i)))-sinpat.phase(i)));    patch = patch+contrast(i)*val;endpatch = patch.*env;if (max(max(abs(patch))) > 1)	error('Contrasts too high-- > 1!');endif ncolors > 0    patch = floor((patch+1)*(ncolors-1)/2);end